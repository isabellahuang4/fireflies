#start with predetermined patterns
#using alpha numbers to characterize pattern
#alphas all integral valued
#limited a_1 and a_2 possibilities to be more realistic?

import sys
import random as r
from statistics import mean
from math import floor
from alpha import Firefly

LENGTH = 10
NUM_SPECIES = 2
NUM_EACH = 20
EPOCHS = 200
PERTURB = 1
MUTATE_PROB = .15 

PATTERNS = [ [0, 1, 2, 8, 1], \
                 [0, 1, 2, 6, 2], \
                 [0, 1, 2, 4, 3], \
                 [0, 1, 2, 2, 4], \
                 [0, 1, 2, 0, 5], \
                 [0, 2, 3, 7, 1], \
                 [0, 2, 3, 4, 2], \
                 [0, 2, 3, 1, 3], \
                 [0, 2, 4, 6, 1], \
                 [0, 2, 4, 2, 2], \
                 [0, 3, 4, 6, 1], \
                 [0, 3, 4, 2, 2], \
                 [0, 3, 5, 5, 1], \
                 [0, 3, 5, 0, 2], \
                 [0, 3, 6, 4, 1] ]    
    
def create_fireflies(p):
    #create fireflies
    fireflies = [0] * (NUM_SPECIES * NUM_EACH)
    for i in range(NUM_SPECIES):
        for j in range(NUM_EACH):
            fireflies[j+(NUM_EACH*i)] = Firefly(i)
            fireflires[j+(NUM_EACH*i)].pattern = p[i]
    return fireflies

#p is LIST of start patterns for each species
def run_simulation(p):
    fireflies = create_fireflies(p)

    for epoch in range(EPOCHS):
        r.shuffle(fireflies)

        for f in range(NUM_EACH):
            i = 2*f
            j = i+1
            same = fireflies[i].same_species(fireflies[j])
            #same species
            if same:
                #both no pattern
                if fireflies[i].pattern == None and fireflies[j].pattern == None:
                    fireflies[i].init_pattern()
                    fireflies[j].pattern = fireflies[i].pattern
                #j has pattern
                elif fireflies[i].pattern == None:
                    fireflies[i].pattern = fireflies[j].pattern
                #i has pattern
                elif fireflies[j].pattern == None:
                    fireflies[j].pattern = fireflies[i].pattern
                #both have
                else:
                    #compare aggregate sim scores, replicate higher one 
                    #with probability simscore/length
                    #when replicating, do so with chance of mutation
                    if fireflies[i].simscore >= fireflies[j].simscore:
                        fireflies[j].pattern = fireflies[i].pattern
                        if r.random() < MUTATE_PROB and epoch < 175:
                            fireflies[j].mutate()
                        fireflies[j].reset_simscore()
                    else:
                        fireflies[i].pattern = fireflies[j].pattern
                        if r.random() < MUTATE_PROB and epoch < 175:
                            fireflies[i].mutate()
                        fireflies[i].reset_simscore()
            #diff species
            else:
                if fireflies[i].pattern == None:
                    fireflies[i].init_pattern()
                if fireflies[j].pattern == None:
                    fireflies[j].init_pattern()
                distance = fireflies[i].calc_similarity(fireflies[j])
                fireflies[i].update_simscore(distance)
                fireflies[j].update_simscore(distance)


def main(args):
    #do every possible first pairing, save the final results
    for i in range(len(PATTERNS)):
        for j in range(i+1, len(PATTERNS)):
            print(i, j)
                    



if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
